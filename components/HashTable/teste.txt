func DeleteHash(hash_table *Hash, Nome_Delete string, Telefone_Delete string) {
	// Calcula a posição do elemento a ser deletado
	Position := Peso_strings(Nome_Delete, hash_table)

	// Cria um alias para o VetorHash na posição
	Hash := &hash_table.Indices[Position]

	// Se o VetorHash na posição tem colisão
	if Hash.Verificador_colisao {
		count := 0
		current := Hash.Dados_Usuario
		Current_Prev := Hash.Dados_Usuario

		// Se o telefone do usuário atual é igual ao telefone auxiliar
		if current.Telefone == Telefone_Delete {
			// Remove o usuário atual
			Hash.Dados_Usuario = current.Next
			return
		}

		// Enquanto o telefone do usuário atual não for igual ao telefone auxiliar
		for current.Telefone != Telefone_Delete {
			if count == 0 {
				current = current.Next
				count++
			} else {
				current = current.Next
				Current_Prev = Current_Prev.Next
				// Se o usuário atual for nil, imprime uma mensagem e retorna
				if current == nil {
					fmt.Println("Contato nao encontrado")
					return
				}
			}
		}

		count = 0
		// Se o nome do usuário atual é igual ao nome a ser deletado
		if current.Nome == Nome_Delete {
			// Remove o usuário atual
			Current_Prev.Next = current.Next
		} else {
			fmt.Println("Contato nao encontrado")
			return
		}

		// Define o verificador de colisão como falso
		hash_table.Indices[Position].Verificador_colisao = false
		current2 := Hash.Dados_Usuario
		// Enquanto o próximo usuário não for nil
		for current2.Next != nil {
			// Se o nome do usuário atual não for igual ao nome do próximo usuário
			if current2.Nome != current2.Next.Nome {
				// Define o verificador de colisão como verdadeiro
				hash_table.Indices[Position].Verificador_colisao = true
			}
			current2 = current2.Next
		}
	} else {
		// Se o próximo usuário for nil
		if Hash.Dados_Usuario.Next == nil {
			// Remove o usuário atual
			Hash.Dados_Usuario = nil
			// Define o verificador de colisão como falso
			Hash.Verificador_colisao = false
			Referencias_auxiliar := make([]int, 0)
			// Para cada conteúdo na lista de referências
			for _, conteudo := range hash_table.Referencias {
				// Se o conteúdo não for igual à posição
				if conteudo != Position {
					// Adiciona o conteúdo ao vetor auxiliar de referências
					Referencias_auxiliar = append(Referencias_auxiliar, conteudo)
				}
			} // Atualiza a lista de referências
			hash_table.Referencias = Referencias_auxiliar
		} else {
			//Essa parte é apenas para teste -> integração com o front
			fmt.Printf("Qual %s Deseja remover?\n", Nome_Delete)
			BuscaHash(hash_table, Nome_Delete)
			fmt.Printf("Especifique o Numero do %s para remover o contato\n", Nome_Delete)
			fmt.Scanf("%s", &Telefone_Auxiliar)
			/* ------------------------------------ */

			count := 0
			current := Hash.Dados_Usuario
			Current_Prev := Hash.Dados_Usuario

			// Se o telefone do usuário atual é igual ao telefone auxiliar
			if current.Telefone == Telefone_Auxiliar {
				// Remove o usuário atual
				Hash.Dados_Usuario = current.Next
				return
			}

			// Enquanto o telefone do usuário atual não for igual ao telefone auxiliar
			for current.Telefone != Telefone_Auxiliar {
				if count == 0 {
					current = current.Next
					count++
				} else {
					current = current.Next
					Current_Prev = Current_Prev.Next
					// Se o usuário atual for nil, imprime uma mensagem e retorna
					if current == nil {
						fmt.Println("Contato nao encontrado")
						return
					}
				}
			}
			count = 0
			// Se o nome do usuário atual é igual ao nome a ser deletado
			if current.Nome == Nome_Delete {
				// Remove o usuário atual
				Current_Prev.Next = current.Next
			} else {
				fmt.Println("Contato nao encontrado")
				return
			}

			// Define o verificador de colisão como falso
			Hash.Verificador_colisao = false
		}
	}
}
